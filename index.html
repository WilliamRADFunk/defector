<html>

<head>
	<script src="js/three.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
</head>

<body>

<div id="main" width="94%" height="94%" style="position:relative;">
	<div id="mainview" width="100%" height="100%" style="position:absolute"></div>
	<div id="hudview" width="5%" height="5%" style="position:absolute; left:20px; bottom:20px; z-index:1000" ></div>
</div>

<script>
	var renderer, renderer2;
	var scene;
	var camera, hudcamera;
	var ball;

	var step = 0.7;
	var scenewidth = 200, sceneheight = 200;
	
	keyboard = new THREEx.KeyboardState();
	
	function init()
	{
		scene = new THREE.Scene();
	
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 3000 );
		camera.position.x = 0;
		camera.position.y = 0;
		camera.position.z = 5;
		camera.rotation.x = 0;
		camera.rotation.y = 0;
		camera.rotation.z = 0;
		var pos = new THREE.Vector3( 0, 200, 0 );
		camera.lookAt( pos );
		
		//hudcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 3000 );
		hudcamera = new THREE.OrthographicCamera( -100, 100, 100, -100, 0.1, 3000, 3 );
		hudcamera.position.x = 0;
		hudcamera.position.y = 0;
		hudcamera.position.z = 300;
		hudcamera.lookAt( scene.position );
		
		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0x000000, 0 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMapEnabled = true;

		renderer2 = new THREE.WebGLRenderer();
		renderer2.setClearColor( 0x000000, 0 );
		renderer2.setSize( 150, 150 );
		renderer2.shadowMapEnabled = false;
		
		addFloorCieling();
		addWalls();

		// add spotlight for the shadows
        var spotLight = new THREE.SpotLight( 0xffffff );
        spotLight.position.set( 10, 20, 20 );
        spotLight.shadowCameraNear = 20;
        spotLight.shadowCameraFar = 50;
        spotLight.castShadow = true;
        scene.add(spotLight);
		
		var ballgeo = new THREE.SphereGeometry( 4 );
		var ballmat = new THREE.MeshBasicMaterial({color:'white'});
		ball = new THREE.Mesh( ballgeo, ballmat );
		scene.add( ball );
		
		renderer.autoClear = false;
		renderer2.autoClear = false;

		var container = document.getElementById("mainview");
		document.body.appendChild( container );
		container.appendChild( renderer.domElement );
		
		var container2 = document.getElementById("hudview");
		document.body.appendChild( container2 );
		container2.appendChild( renderer2.domElement );
		
		render();
	}

		function addFloorCieling()
	{
		var floorTexture = THREE.ImageUtils.loadTexture('assets/textures/wood-floorboards-texture.jpg');
		floorTexture.wrapS = THREE.RepeatWrapping;
		floorTexture.wrapT = THREE.RepeatWrapping;
		floorTexture.repeat.set( 10, 10 );
		var floorGeometry = new THREE.BoxGeometry( scenewidth, sceneheight, 1 );
		var floorMaterial = new THREE.MeshBasicMaterial({map:floorTexture});
		var floor = new THREE.Mesh( floorGeometry, floorMaterial );
		scene.add( floor );

		var ceilingTexture = THREE.ImageUtils.loadTexture('assets/textures/tile-ceiling.jpg');
		ceilingTexture.wrapS = THREE.RepeatWrapping;
		ceilingTexture.wrapT = THREE.RepeatWrapping;
		ceilingTexture.repeat.set( 30, 30 );
		var ceilingGeometry = new THREE.PlaneGeometry( scenewidth, sceneheight, 1 );
		var ceilingMaterial = new THREE.MeshBasicMaterial( {map:ceilingTexture, side: THREE.BackSide} );
		var ceiling = new THREE.Mesh( ceilingGeometry, ceilingMaterial );
		ceiling.position.z = 15;
		scene.add( ceiling );
	}
	
	function addAWall( x, y, z, xp, yp, zp, texture )
	{
		var wallg = new THREE.BoxGeometry( x, y, z );
		var wallm = new THREE.MeshBasicMaterial({map:texture});
		var wallmesh = new THREE.Mesh( wallg, wallm );
		wallmesh.position.z = zp;
		wallmesh.position.y = yp;
		wallmesh.position.x = xp;
		scene.add( wallmesh );
	}
	
	function addWalls()
	{
		var texturex = THREE.ImageUtils.loadTexture('assets/textures/brick-1.jpg');
		texturex.wrapS = THREE.RepeatWrapping;
		texturex.wrapT = THREE.RepeatWrapping;
		texturex.repeat.set( 6, 1 );

		var texturey = THREE.ImageUtils.loadTexture('assets/textures/brick-1.jpg');
		texturey.wrapS = THREE.RepeatWrapping;
		texturey.wrapT = THREE.RepeatWrapping;
		texturey.repeat.set( 1, 6 );
		
		addAWall( scenewidth, 5, 15, 0, (sceneheight / 2), 7.5, texturex );
		addAWall( scenewidth, 5, 15, 0, -(sceneheight / 2), 7.5, texturex );
		addAWall( 5, sceneheight, 15, -(scenewidth / 2), 0, 7.5, texturey );
		addAWall( 5, sceneheight, 15, (scenewidth / 2), 0, 7.5, texturey );
	}

	function moveCamera( xd, yd )
	{
		var x = camera.position.x + step * Math.sin( camera.rotation.y ) * xd;
		var y = camera.position.y + step * Math.cos( camera.rotation.y ) * yd;
			
		if( x < -( scenewidth / 2 ) )
		{
			x = -( scenewidth / 2 ) + 5;
			two.play();
		}
		else if( x > ( scenewidth / 2 ) )
		{
			x = ( scenewidth / 2 ) - 5;
			two.play();
		}
		
		if( y < -( sceneheight / 2 ) )
		{
			y = -( sceneheight / 2 ) + 5;
			two.play();
		}
		else if( y > ( sceneheight / 2 ) )
		{
			y = ( sceneheight / 2 ) - 5;
			two.play();
		}
			
		camera.position.x = x;
		camera.position.y = y;
		
		ball.position.x = camera.position.x;
		ball.position.y = camera.position.y;
		ball.position.z = camera.position.z;
	}
	
	function render()
	{
		if( keyboard.pressed("reset") )
		{
			landed = false;
			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 1000;
			camera.rotation.x = 0;
			camera.rotation.y = 0;
			camera.rotation.z = 0;
			camera.lookAt( scene.position );
			
			ball.position.x = camera.position.x;
			ball.position.y = camera.position.y;
			ball.position.z = camera.position.z;
		}
		else if( keyboard.pressed("land") )
		{
			landed = true;
			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 10;
			camera.rotation.x = 0;
			camera.rotation.y = 0;
			camera.rotation.z = 0;
			var pos = new THREE.Vector3( 0, 200, 0 );
			camera.lookAt( pos );
			
			ball.position.x = camera.position.x;
			ball.position.y = camera.position.y;
			ball.position.z = camera.position.z;
		}
		else if( keyboard.pressed("right") && keyboard.pressed("forward") )
		{
			camera.rotation.y -= 0.02;
			moveCamera( -1, 1 );
		}
		else if( keyboard.pressed("left") && keyboard.pressed("forward") )
		{
			camera.rotation.y += 0.02;
			moveCamera( -1, 1 );
		}
		else if( keyboard.pressed("left") && keyboard.pressed("backward") )
		{
			camera.rotation.y -= 0.02;
			moveCamera( 1, -1 );
		}
		else if( keyboard.pressed("right") && keyboard.pressed("backward") )
		{
			camera.rotation.y += 0.02;
			moveCamera( 1, -1 );
		}
		else if( keyboard.pressed("right") )
		{
			camera.rotation.y -= 0.02;
		}
		else if( keyboard.pressed("left") )
		{
			camera.rotation.y += 0.02;
		}
		else if( keyboard.pressed("forward") )
		{
			moveCamera( -1, 1 );
		}
		else if( keyboard.pressed("backward") )
		{
			moveCamera( 1, -1 );
		}
	
		requestAnimationFrame( render );
		
		renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );
		renderer.render( scene, camera );
		
		var aspect = 1;//window.innerWidth / window.innerHeight;
		renderer2.enableScissorTest(true);
		var horz_ratio = window.innerWidth/window.innerHeight;
		renderer2.setViewport( 0, 0, 150 * aspect, 150* aspect);
		//renderer2.setScissor( 0, 0, 200 * aspect/horz_ratio, 200* aspect*horz_ratio  );
		renderer2.render( scene, hudcamera );
	}
	
	window.onload = init;
</script>

<script>
</script>

</body>

</html>

<html>

<head>
	<script src="js/three.js"></script>
	<script src="js/threex.keyboardstate.js"></script>
</head>

<body>

<div id="main" width="97%" height="97%" style="position:relative;">
	<div id="mainview" width="100%" height="100%" style="position:absolute"></div>
	<div id="hudview" width="10%" height="10%" style="position:absolute; left:20px; bottom:20px; z-index:1000" ></div>
</div>

<script>
	var renderer, renderer2;
	var scene;
	var camera, hudcamera;
	var ball;

	var step = 1;
	var scenewidth = 400, sceneheight = 400;
	
	keyboard = new THREEx.KeyboardState();
	
	function init()
	{
		scene = new THREE.Scene();
	
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 3000 );
		camera.position.x = 0;
		camera.position.y = 0;
		camera.position.z = 10;
		camera.rotation.x = 0;
		camera.rotation.y = 0;
		camera.rotation.z = 0;
		var pos = new THREE.Vector3( 0, 200, 0 );
		camera.lookAt( pos );
		
		hudcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		hudcamera.position.x = 0;
		hudcamera.position.y = 0;
		hudcamera.position.z = 300;
		hudcamera.lookAt( scene.position );
		
		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0x000000, 0 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMapEnabled = true;

		renderer2 = new THREE.WebGLRenderer();
		renderer2.setClearColor( 0x000000, 0 );
		renderer2.setSize( 200, 200 );
		renderer2.shadowMapEnabled = true;
		
		addTerrain();
		addWalls();

		// add spotlight for the shadows
        var spotLight = new THREE.SpotLight( 0xffffff );
        spotLight.position.set( 10, 20, 20 );
        spotLight.shadowCameraNear = 20;
        spotLight.shadowCameraFar = 50;
        spotLight.castShadow = true;
        scene.add(spotLight);
		
		var ballgeo = new THREE.SphereGeometry( 20 );
		var ballmat = new THREE.MeshBasicMaterial({color:'green'});
		ball = new THREE.Mesh( ballgeo, ballmat );
		scene.add( ball );
		
		renderer.autoClear = false;
		renderer2.autoClear = false;

		var container = document.getElementById("mainview");
		document.body.appendChild( container );
		container.appendChild( renderer.domElement );
		
		var container2 = document.getElementById("hudview");
		document.body.appendChild( container2 );
		container2.appendChild( renderer2.domElement );
		
		render();
	}

		function addTerrain()
	{
		var texture = THREE.ImageUtils.loadTexture('assets/textures/wooden-floor-dark-texture.jpg');
		var planegeo = new THREE.BoxGeometry( scenewidth, sceneheight, 4 );
		var planemat = new THREE.MeshBasicMaterial({map:texture});
		var mesh = new THREE.Mesh( planegeo, planemat );
		scene.add( mesh );
	}
	
	function addAWall( x, y, z, xp, yp, texture )
	{
		var wallg = new THREE.BoxGeometry( x, y, z );
		var wallm = new THREE.MeshBasicMaterial({map:texture});
		var wallmesh = new THREE.Mesh( wallg, wallm );
		wallmesh.position.y = yp;
		wallmesh.position.x = xp;
		scene.add( wallmesh );
	}
	
	function addWalls()
	{
		var texture = THREE.ImageUtils.loadTexture('assets/textures/brick-1.jpg');
		
		addAWall( scenewidth + 100, 50, 40, 0, ( sceneheight / 2 + 26 ), texture );
		addAWall( scenewidth + 100, 50, 40, 0, -( sceneheight / 2 + 26 ), texture );
		addAWall( 50, sceneheight, 40, -( scenewidth / 2 + 26 ), 0, texture );
		addAWall( 50, sceneheight, 40, ( scenewidth / 2 + 26 ), 0, texture );
	}

	function moveCamera( xd, yd )
	{
		var x = camera.position.x + step * Math.sin( camera.rotation.y ) * xd;
		var y = camera.position.y + step * Math.cos( camera.rotation.y ) * yd;
			
		if( x < -( scenewidth / 2 ) )
		{
			x = -( scenewidth / 2 ) + 5;
			two.play();
		}
		else if( x > ( scenewidth / 2 ) )
		{
			x = ( scenewidth / 2 ) - 5;
			two.play();
		}
		
		if( y < -( sceneheight / 2 ) )
		{
			y = -( sceneheight / 2 ) + 5;
			two.play();
		}
		else if( y > ( sceneheight / 2 ) )
		{
			y = ( sceneheight / 2 ) - 5;
			two.play();
		}
			
		camera.position.x = x;
		camera.position.y = y;
		
		ball.position.x = camera.position.x;
		ball.position.y = camera.position.y;
		ball.position.z = camera.position.z;
	}
	
	function render()
	{
		if( keyboard.pressed("reset") )
		{
			landed = false;
			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 1000;
			camera.rotation.x = 0;
			camera.rotation.y = 0;
			camera.rotation.z = 0;
			camera.lookAt( scene.position );
			
			ball.position.x = camera.position.x;
			ball.position.y = camera.position.y;
			ball.position.z = camera.position.z;
		}
		else if( keyboard.pressed("land") )
		{
			landed = true;
			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 10;
			camera.rotation.x = 0;
			camera.rotation.y = 0;
			camera.rotation.z = 0;
			var pos = new THREE.Vector3( 0, 200, 0 );
			camera.lookAt( pos );
			
			ball.position.x = camera.position.x;
			ball.position.y = camera.position.y;
			ball.position.z = camera.position.z;
		}
		else if( keyboard.pressed("right") && keyboard.pressed("forward") )
		{
			camera.rotation.y -= 0.02;
			moveCamera( -1, 1 );
		}
		else if( keyboard.pressed("left") && keyboard.pressed("forward") )
		{
			camera.rotation.y += 0.02;
			moveCamera( -1, 1 );
		}
		else if( keyboard.pressed("left") && keyboard.pressed("backward") )
		{
			camera.rotation.y -= 0.02;
			moveCamera( 1, -1 );
		}
		else if( keyboard.pressed("right") && keyboard.pressed("backward") )
		{
			camera.rotation.y += 0.02;
			moveCamera( 1, -1 );
		}
		else if( keyboard.pressed("right") )
		{
			camera.rotation.y -= 0.02;
		}
		else if( keyboard.pressed("left") )
		{
			camera.rotation.y += 0.02;
		}
		else if( keyboard.pressed("forward") )
		{
			moveCamera( -1, 1 );
		}
		else if( keyboard.pressed("backward") )
		{
			moveCamera( 1, -1 );
		}
	
		requestAnimationFrame( render );
		
		renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );
		renderer.render( scene, camera );
		
		var aspect = 1;//window.innerWidth / window.innerHeight;
		renderer2.enableScissorTest(true);
		var horz_ratio = window.innerWidth/window.innerHeight;
		renderer2.setViewport( 0, 0, 150 * aspect, 100* aspect);
		//renderer2.setScissor( 0, 0, 200 * aspect/horz_ratio, 200* aspect*horz_ratio  );
		renderer2.render( scene, hudcamera );
	}
	
	window.onload = init;
</script>

<script>
</script>

</body>

</html>
